# App Documentation

## Overview
A mobile app for tracking and splitting group expenses. Perfect for trips, shared housing, or any situation where multiple people need to track shared costs.

## Software Stack

The application is built using the following technologies:

*   **Frontend:** Flutter (using Dart programming language) - For building cross-platform mobile applications from a single codebase.
*   **Backend:** Firebase - A platform providing various backend services:
    *   **Firestore:** A NoSQL document database for storing application data.
    *   **Firebase Authentication:** For handling user sign-up and sign-in (specifically Google Sign-In).
    *   **Firebase Cloud Functions:** For running server-side logic in response to events or HTTP requests (written in TypeScript).
*   **State Management (Flutter):** `provider` package - A popular choice for managing application state in Flutter apps, utilizing `ChangeNotifier` for reactive UI updates.

## Data Models

The application utilizes Firestore as its primary database. The data is organized into several collections and subcollections:

### 1. `publicProfiles`
*   **Purpose:** Stores public information for registered users. This information is accessible to display user details within the app (e.g., names of users in a group). A document is automatically created for each new user via a Firebase Cloud Function.
*   **Document ID:** User's Firebase UID.
*   **Schema:**
    *   `userId` (String): The Firebase User ID.
    *   `displayName` (String): The user's display name (often from their Google account).
    *   `photoURL` (String, nullable): URL to the user's profile picture.
    *   `createdAt` (Timestamp): Server timestamp indicating when the profile was created.

### 2. `transaction_groups`
*   **Purpose:** Represents a shared space for tracking expenses for a specific event, trip, or purpose. Each document is a distinct group.
*   **Document ID:** Auto-generated by Firestore.
*   **Schema:**
    *   `name` (String): The user-defined name for the transaction group (e.g., "Ski Trip 2024", "Apartment Bills").
    *   `defaultCurrencyId` (String): The ID of a document in the `currency_rates` subcollection that serves as the base currency for this group.
    *   `inviteToken` (String): A unique token generated for sharing the group with others.
    *   `sharedWith` (Array of Strings): A list of Firebase User UIDs who have access to this group.
    *   `createdBy` (String): The Firebase User UID of the user who created the group.
    *   `createdAt` (Timestamp): Server timestamp of when the group was created.
    *   *(Other fields might exist, like `owner` or specific settings, but these are the core ones observed).*

### 3. `participants` (Subcollection of `transaction_groups`)
*   **Parent:** Each document in `transaction_groups`.
*   **Collection Path:** `transaction_groups/{groupId}/participants`
*   **Purpose:** Stores the individuals who are part of a transaction group and can be involved in transactions (as payers or payees). These participants do not necessarily need to be registered users of the app.
*   **Document ID:** Auto-generated by Firestore.
*   **Schema:**
    *   `name` (String): The name of the participant (e.g., "Alice", "Bob"). This name is used to identify them in transactions.

### 4. `currency_rates` (Subcollection of `transaction_groups`)
*   **Parent:** Each document in `transaction_groups`.
*   **Collection Path:** `transaction_groups/{groupId}/currency_rates`
*   **Purpose:** Defines the accepted currencies and their exchange rates within a specific transaction group, relative to a base currency (often implied by one of the rates being 1, or related to `defaultCurrencyId` in the parent group).
*   **Document ID:** Auto-generated by Firestore (but also referenced by `defaultCurrencyId` in the parent `transaction_groups` document for the default currency).
*   **Schema:**
    *   `symbol` (String): The currency symbol or code (e.g., "USD", "EUR", "JPY").
    *   `rate` (Number): The exchange rate. The interpretation of this rate (e.g., relative to the group's default currency) is handled by the application logic.

### 5. `transactions` (Subcollection of `transaction_groups`)
*   **Parent:** Each document in `transaction_groups`.
*   **Collection Path:** `transaction_groups/{groupId}/transactions`
*   **Purpose:** Records individual expense items within a transaction group.
*   **Document ID:** Auto-generated by Firestore.
*   **Schema:**
    *   `description` (String): A description of the transaction (e.g., "Dinner", "Groceries").
    *   `amount` (Number): The monetary value of the transaction.
    *   `currencySymbol` (String): The symbol of the currency in which the transaction was made (should match a `symbol` in the group's `currency_rates`).
    *   `payer` (String): The name of the participant (from the group's `participants` list) who paid for this transaction.
    *   `payees` (Array of Strings): A list of names of participants (from the group's `participants` list) who were involved in or benefited from this transaction.
    *   `timestamp` (Timestamp): The date and time when the transaction occurred or was recorded.
    *   `addedBy` (String, optional): UID of the user who added the transaction.

## Core Business Logic / Features

The application provides several key features to help users manage shared expenses:

### 1. User Authentication
*   **Google Sign-In:** Users can sign up or sign in to the app using their Google accounts. This process is handled by Firebase Authentication.
*   **Automatic Public Profile Creation:** Upon a new user's first successful sign-in, a Firebase Cloud Function (`createPublicProfile`) is triggered. This function creates a document in the `publicProfiles` collection in Firestore, storing the user's ID, display name, and photo URL. This profile is used to display user information within the app where needed (e.g., identifying who created a group).

### 2. Transaction Group Management
*   **Creation:** Authenticated users can create new transaction groups. When creating a group, they provide a name and a default currency. The user who creates the group is automatically added to its `sharedWith` list and recorded as `createdBy`.
*   **Joining:** Users can join existing transaction groups if they have an `inviteToken`. This token is entered in the app, and a Firebase Cloud Function (`addUserToGroup`) is called. This function validates the token, and if valid, adds the current user's UID to the `sharedWith` array of the respective group, granting them access.
*   **Sharing:** Users within a group can share its `inviteToken` with others to allow them to join.
*   **Real-time Updates:** The app listens for real-time updates to transaction groups the user is part of, ensuring data is synchronized across devices.

### 3. Expense Tracking (Transactions)
*   **Adding Transactions:** Users can add new expense transactions within a group. For each transaction, they record:
    *   A description of the expense.
    *   The amount paid.
    *   The currency of the transaction (selected from the group's defined currencies).
    *   The participant who paid (the "payer").
    *   The participants who benefited from or were part of the expense (the "payees").
*   **Multi-Currency Support:** Each transaction group can have multiple currencies defined, each with an exchange rate. Transactions can be recorded in any of these defined currencies. The `SettlementService` uses these rates to normalize amounts when calculating balances.

### 4. Participant Management
*   **Adding Participants:** Users can add participants to a transaction group. These participants are simply names (e.g., "Alice", "Friend from work") and do not need to be registered users of the app. They are used to assign payers and payees in transactions.
*   **Removing Participants:** Participants can be removed from a group, typically if they are not involved in any transactions.

### 5. Currency Management
*   **Adding Currencies and Rates:** Within each group, users can define a list of currencies (e.g., USD, EUR, CAD) and specify their exchange rates. One currency is set as the group's default.
*   **Updating Rates:** Exchange rates can be updated as needed.
*   **Removing Currencies:** Currencies can be removed, usually if they are not the default and not used in any transactions.

### 6. Settlement Calculation
*   **Client-Side Calculation:** The app includes a `SettlementService` (located in `lib/services/settlement_service.dart`). This service takes all transactions, participant lists, and currency exchange rates for a group.
*   **Determining Balances:** It calculates the net balance for each participant, considering how much they've paid and how much they owe from shared expenses. It converts amounts to a common baseline using the defined exchange rates.
*   **Suggesting Transfers:** The service then determines the simplest set of transfers required to settle all debts within the group (e.g., "Alice owes Bob $20"). These settlements are displayed to the user but are not explicitly stored back into Firestore as persistent records; they are recalculated on demand.

## Application State Management

The application employs the `provider` package for state management, a common and recommended approach in Flutter development. The core of this is the `AppState` class (`lib/providers/app_state.dart`).

*   **`AppState` Class:**
    *   Extends `ChangeNotifier`, allowing widgets to subscribe to its changes and rebuild when the state updates.
    *   It is provided at the top of the widget tree (in `main.dart`) using `ChangeNotifierProvider`.
*   **Responsibilities:**
    *   **User Authentication State:** Manages the current Firebase `User` object and listens to authentication state changes (`_auth.authStateChanges()`).
    *   **Data Fetching and Caching:**
        *   Fetches and holds the list of `transactionGroups` the current user is part of.
        *   When a specific transaction group is selected (`_currentTransactionGroup`), it sets up real-time Firestore listeners for that group's subcollections: `participants`, `currency_rates`, and `transactions`.
        *   Maintains a cache for `PublicProfile` objects (`_publicProfileCache`) to reduce redundant Firestore reads when fetching user display names.
    *   **Holding Current State:** Stores the currently active transaction group, its associated participants, currencies, transactions, and calculated settlements.
    *   **Business Logic Interface:** Provides methods that UI components can call to perform actions like adding/removing data (transactions, participants, etc.), signing in/out, and calculating settlements. These methods often interact with Firebase services (Firestore, Cloud Functions).
    *   **Loading State:** Manages an `isLoading` flag to indicate background activity, which can be used by the UI to show progress indicators.
    *   **View Toggling:** Manages UI state like `_showTransactions` to toggle between views (e.g., transactions list vs. settlements display).
*   **Real-time Updates:**
    *   `AppState` makes extensive use of Firestore's `snapshots()` streams to listen for real-time data changes. When data changes in Firestore (e.g., a new transaction is added by another group member), the stream emits an update.
    *   `AppState` then updates its internal lists and calls `notifyListeners()`. This, in turn, causes any listening widgets in the UI to rebuild and reflect the new data.
*   **Dependency Management:**
    *   Initializes and holds instances of necessary services like `FirebaseAuth`, `GoogleSignIn`, `FirebaseFirestore`, and `FirebaseFunctions`.
*   **Lifecycle Management:**
    *   Includes a `dispose()` method to cancel all active stream subscriptions when `AppState` is no longer needed, preventing memory leaks.

In essence, `AppState` acts as a centralized hub for the application's data and business logic, bridging the UI with the Firebase backend and ensuring that the UI stays reactive to data changes.

## Screens Overview

The application's user interface is composed of several screens, each serving a specific purpose. The primary screens are located in the `lib/screens/` directory:

*   **`SignInScreen.dart`:**
    *   The initial screen for unauthenticated users, providing the option to sign in using Google.
*   **`HomeScreen.dart`:**
    *   The main screen displayed after a user successfully logs in. It typically shows a list of transaction groups the user is a member of, and provides options to create a new transaction group or join an existing one using an invite token.
*   **`TransactionGroupScreen.dart`:**
    *   Displays the detailed view of a selected transaction group. This screen is the central hub for managing a specific group and usually contains:
        *   A list of transactions.
        *   A list of participants.
        *   Calculated settlements (who owes whom).
        *   Options to add new transactions, manage participants, and manage currency rates for the group.
        *   An option to share the group's invite token.
*   **`AddTransactionScreen.dart`:**
    *   A form used to add a new expense/transaction to the currently active transaction group. Users input details like description, amount, currency, payer, and payees.
*   **`ManageParticipantsScreen.dart`:**
    *   A dedicated screen for managing the participants of the current transaction group. Users can add new participants or remove existing ones.
*   **`ManageCurrencyRatesScreen.dart`:**
    *   Allows users to manage the currency rates for the current transaction group. This includes adding new currencies, defining their exchange rates, and potentially modifying or removing existing ones.

## Firebase Cloud Functions

The application utilizes Firebase Cloud Functions (written in TypeScript, located in the `functions/src/index.ts` file) for backend logic that requires elevated privileges or needs to be triggered by Firebase events.

### 1. `createPublicProfile`
*   **Trigger:** Firebase Authentication `onCreate` user trigger. This function automatically runs whenever a new user account is created in Firebase Authentication.
*   **Purpose:** To create a corresponding user profile document in the `publicProfiles` collection in Firestore.
*   **Logic:**
    1.  Receives the newly created `User` object from Firebase Authentication.
    2.  Constructs a `publicProfile` object containing the `userId`, `displayName` (from the auth user object, often Google display name), and `photoURL`.
    3.  Saves this `publicProfile` object as a new document in the `publicProfiles` collection, using the user's UID as the document ID.
*   **Significance:** Ensures that every registered user has a basic public profile available in Firestore, which can be queried by the app to display user information without exposing sensitive auth details.

### 2. `addUserToGroup`
*   **Trigger:** HTTPS Callable Function. This function can be called directly from the client application.
*   **Purpose:** To securely allow a user to join an existing transaction group using an `inviteToken`.
*   **Logic:**
    1.  **Authentication Check:** Verifies that the request is made by an authenticated user. If not, it throws an error.
    2.  **Input Validation:** Expects an `inviteToken` (string) in the request data.
    3.  **Token Query:** Queries the `transaction_groups` collection in Firestore to find a group that has a matching `inviteToken`.
    4.  **User Addition:** If a group is found:
        *   It retrieves the group's ID.
        *   It updates the group's document by adding the authenticated user's UID to the `sharedWith` array (using `FieldValue.arrayUnion` to prevent duplicates).
    5.  **Response:** Returns a success status and the `groupId` if the operation is successful, or an error if the token is invalid, the group is not found, or any other issue occurs.
*   **Significance:** Provides a controlled and secure way to manage group membership. Instead of allowing clients to directly modify the `sharedWith` array (which could be a security risk), this function acts as a gatekeeper, validating the invite process.

## Project Directory Structure

The project follows a standard Flutter project structure, with additional directories for Firebase functions and platform-specific code. Here's an overview of the key directories:

*   **`/` (Root Directory):**
    *   `pubspec.yaml`: Defines project metadata, dependencies (Flutter packages), and assets.
    *   `README.md`: General information about the project, setup, etc.
    *   `DOCUMENTATION.md`: This file, containing detailed documentation of the app.
    *   `firebase.json`: Configuration for Firebase CLI, defining how to deploy functions, hosting, etc.
    *   `.firebaserc`: Specifies the Firebase project to be used.

*   **`lib/`:**
    *   This is the main directory for the Flutter application's Dart code.
    *   `main.dart`: The entry point of the Flutter application.
    *   `models/`: Contains Dart classes representing the data structures used in the app (e.g., `Transaction`, `TransactionGroup`).
    *   `providers/`: Holds state management classes, primarily `AppState.dart`.
    *   `screens/`: Contains the Dart files for different UI screens of the application.
    *   `services/`: Includes Dart classes that provide specific functionalities, like `AuthService.dart` for authentication logic and `SettlementService.dart` for calculating settlements.
    *   `dialogs/`: UI components for various dialog boxes shown in the app.
    *   `utils/`: Utility functions and helper classes.

*   **`functions/`:**
    *   Contains the source code for Firebase Cloud Functions.
    *   `src/index.ts`: The main TypeScript file where cloud functions are defined.
    *   `package.json`: Defines dependencies for the cloud functions (Node.js environment).
    *   `tsconfig.json`: TypeScript compiler configuration.

*   **`android/`:**
    *   Contains Android-specific project files and code. Flutter uses this to build the Android version of the app.
    *   `app/build.gradle`: Android build configuration.

*   **`ios/`:**
    *   Contains iOS-specific project files and code (Swift/Objective-C). Flutter uses this to build the iOS version of the app.
    *   `Runner.xcworkspace`: Xcode workspace file.

*   **`web/`:**
    *   Contains files for building the web version of the Flutter app, if applicable.
    *   `index.html`: The main HTML page for the web app.

*   **`macos/`, `windows/`, `linux/`:**
    *   Platform-specific code and project files for desktop builds of the Flutter application, if supported and configured.

*   **`test/`:**
    *   Contains unit tests and widget tests for the Dart code in `lib/`.
    *   Example: `settlement_service_test.dart`.

*   **`.github/workflows/`:**
    *   Contains YAML files defining GitHub Actions workflows, typically for Continuous Integration and Continuous Deployment (CI/CD) pipelines (e.g., building the app, deploying to Firebase Hosting).
